/**
 * @license Copyright (c) 2003-2025, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-licensing-options
 */

/**
 * @module paste-from-office/filters/unwrapmslistsparaborders
 */

import {
	ViewTreeWalker,
	type ViewElement,
	type ViewDocumentFragment,
	type ViewItem,
	type ViewUpcastWriter
} from 'ckeditor5/src/engine.js';

/**
 * When a user sets border top or border bottom on list items, Microsoft Word wraps
 * whole list items (which may be H1 elements) with <div> elements. It's problematic
 * because it separates block lists using div elements and continuation of multi level
 * lists is hard to achieve.
 *
 * The HTML generated by Microsoft Word looks like this:
 *
 * 	<div style="mso-element:para-border-div;border-bottom:solid #A7A9AC 2.25pt; ...">
 * 		<h1 style="mso-list:l2 level1 lfo1; mso-border-bottom-alt:solid #A7A9AC 2.25pt; ...">Title</h1>
 * 	</div>
 *
 * In the scenario above, the <div> element should be removed and the alternative border bottom style can be applied to the last element.
 * It results in the following HTML structure:
 *
 * 	<h1 style="mso-list:l2 level1 lfo1; border-bottom:solid #A7A9AC 2.25pt; ...">Title</h1>
 *
 * For elements with border top, the same logic applies, but the border is applied to the first child of the wrapper element.
 *
 * @internal
 */
export function unwrapMSListsParaBorders( documentFragment: ViewDocumentFragment, writer: ViewUpcastWriter ): void {
	const range = writer.createRangeIn( documentFragment );
	const walker = new ViewTreeWalker( {
		boundaries: range,
		ignoreElementEnd: true
	} );

	const unwrapElements = new Set<ViewElement>();

	for ( const { item } of range ) {
		if ( !isParaBorderWrapperElement( item ) || !hasAnyListLikeElement( item, writer ) ) {
			continue;
		}

		unwrapElements.add( item );

		// Avoid processing children of the current item as they will be processed by the walker.
		walker.jumpTo( writer.createPositionAfter( item ) );
	}

	for ( const wrapper of unwrapElements ) {
		const wrapperBorders = pickElementBorders( wrapper );
		const children = [ ...wrapper.getChildren() ] as Array<ViewElement>;

		// Cleanup alternative border styles from children.
		for ( const child of children ) {
			writer.removeStyle( 'mso-border-bottom-alt', child );
			writer.removeStyle( 'mso-border-top-alt', child );
		}

		// If there is border bottom, move selection to the last element.
		if ( wrapperBorders.bottom ) {
			const lastChild = children.at( -1 );

			if ( lastChild ) {
				if ( lastChild.getStyle( 'border' ) === 'none' ) {
					writer.removeStyle( 'border', lastChild );
				}

				writer.setStyle( 'border-bottom', wrapperBorders.bottom, lastChild );
			}
		}

		// If there is border top, move selection to the first element.
		if ( wrapperBorders.top ) {
			const firstChild = children[ 0 ];

			if ( firstChild ) {
				if ( firstChild.getStyle( 'border' ) === 'none' ) {
					writer.removeStyle( 'border', firstChild );
				}

				writer.setStyle( 'border-top', wrapperBorders.top, firstChild );
			}
		}

		writer.insertChild( wrapper.index!, children, wrapper.parent! );
		writer.remove( wrapper );
	}
}

/**
 * Para borders seem to be identified by `mso-element: para-border-div` style.
 */
function isParaBorderWrapperElement( wrapper: ViewItem ): wrapper is ViewElement {
	return wrapper.is( 'element' ) && wrapper.getStyle( 'mso-element' ) === 'para-border-div';
}

/**
 * Checks if the element or any of its children have a list-like style.
 */
function hasAnyListLikeElement( element: ViewElement, writer: ViewUpcastWriter ) {
	for ( const child of writer.createRangeIn( element ).getItems() ) {
		if ( child.is( 'element' ) && child.getStyle( 'mso-list' ) ) {
			return true;
		}
	}

	return false;
}

/**
 * Picks all border styles from the element. The alternative ones are used by Microsoft Word as compatibility
 * fallbacks which we can use to unwrap the element.
 */
const MS_PARA_BORDER_DIRECTIONS = [ 'top', 'bottom' ] as const;

function pickElementBorders( wrapper: ViewElement ): ElementBorders {
	return MS_PARA_BORDER_DIRECTIONS.reduce<ElementBorders>(
		( borders, direction ) => {
			const key = `border-${ direction }`;

			if ( wrapper.hasStyle( key ) && wrapper.getStyle( key ) !== 'none' ) {
				borders[ direction ] = wrapper.getStyle( key )!;
			}

			return borders;
		},
		Object.create( null )
	);
}

type MSParaBorderDirections = typeof MS_PARA_BORDER_DIRECTIONS[number];

type ElementBorders = {
	[ direction in MSParaBorderDirections ]?: string
};
